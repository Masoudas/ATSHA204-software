/*******************************************************************************
********************************************************************************
*@ File:	ATSHA_Authentication_PL1.c
****************************************
*@ Company:	Sadr Electronic Dena Co.

*@ Version:	1.0
*@ Update:	Last:96/07/11	Previous:96/07/11	Created:96/07/11
*@ Author:	M. Aghamohamadian.

*@ Brief:	This header contains the main authentication protocol with ATSHA.

*@ Note:        See the report for definition of implementation levels of programmer
                (and authentication) protocols of ATSHA.
********************************************************************************
*******************************************************************************/
#include "ATSHA_Authentication_PL1.h"
#include "ATSHA_PL2.h"
#include "ATSHA_Commands_Module.h"
#include "ATSHA_EmulatingSoftware_Module.h"
#include <stdio.h>

PL1_data_struct                  PL1_data; //= {??};
PL1_internal_flags_struct        PL1_internal_flags;// = {???};
sha204h_temp_key                 TempKey;


PL1_flags ATSHA_Authentication_PL1(command_response_struct *pcommand_response, unsigned int current_system_time)
{
  //// Initialization
  PL2_flags                        PL2_output_flag;                   // Output flag of level two.
  PL1_flags                        PL1_output_flag;                   // A local variable to hold the output flag of PL1.
  
  //// Main Commands
  switch (PL1_data.current_PL1_state)    
  {
    case (PL1_INITIALIZATION):       
      memset(&(PL1_data.serial_number[0]), 0, SHA204_MSG_SIZE_MAC);     // Set serial number data to zero.
      Assign_PL1_States(GENERATE_NONCE_1,GENERATE_NONCE_2);          
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;   

    case (GENERATE_NONCE):       
      Generate_Nonce(pcommand_response, current_system_time);       // Generate a nonce in host.
      Assign_PL1_States(GENERATE_NONCE_1, PL2_BUSY_CYCLE);          // The next state assigned here is unneccessary.
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;   

    case (GENERATE_NONCE_1):     
      // Assigning the command buffer (Note: Parameters should always be assigned first!).
      Assign_CommandParams(GN1_NONCE_COMMAND, COMMAND_WORD_ADDRESS, GN1_NONCE_COUNT, GN1_NONCE_OPCODE, GN1_NONCE_PARAM1, GN1_NONCE_PARAM20, GN1_NONCE_PARAM21, pcommand_response);       // Assigning the parameters of a command.
      Assign_CommandData(&(PL_data.Nonce[0]), GN1_NONCE_DATA1_LENGTH, NULL, GN1_NONCE_DATA2_LENGTH, NULL, GN1_NONCE_DATA3_LENGTH, pcommand_response);        // Assigning the data parameters of the command (only 20 bytes of nonce are used).
     
      // Assign response parameters of the command
      Assign_Response_Params(pcommand_response, GN1_NONCE_RESPONSE_LENGTH, SET_ATSHA_IDLE);

      // Determine state transitions  
      Assign_PL1_States(PL2_BUSY_CYCLE, READ_DZ_207);          

      // Assign output flag.
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;   
      
    case (GENERATE_NONCE_2):           
      // Copy the nonce generated by ATSHA to registers.
      memcpy(&(TempKey.value[0]), &((*pcommand_response).response[RESPONSE_COUNT_OFFSET]), ATSHA_NONCE_LENGTH);  // Copy the nonce generated by ATSHA to TempKey register.
      Assign_TempKey(0, TEMPKEY_RAND_SOURCE, TEMPKEY_GENDATA_IGNORE, TEMPKEY_CHECKFLAG_NOGENDIG, TEMPKEY_VALID, *pTempKey);     // Assign the registers of TempKey.
      
      memcpy(&(PL1_data.nonce[0]), &(TempKey.value[0]), TEMPKEY_VALUE_LENGTH);          // Copy the nonce in TempKey.value to nonce[] for future uses.
      
      // Determine state transitions  
      Assign_PL1_States(GENERATE_CHILD_KEY, PL2_BUSY_CYCLE);          

      // Assign output flag.
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;

    case (GENERATE_CHILD_KEY):             
      // Assigning the command buffer
      Assign_CommandParams(GCK_DERIVEKEY_COMMAND, COMMAND_WORD_ADDRESS, GCK_DERIVEKEY_COUNT, GCK_DERIVEKEY_OPCODE, GCK_DERIVEKEY_PARAM1, GCK_DERIVEKEY_PARAM20, GCK_DERIVEKEY_PARAM21, pcommand_response);       // Assigning the parameters of a command.
      Assign_CommandData(NULL, GCK_DERIVEKEY_DATA1_LENGTH, NULL, GCK_DERIVEKEY_DATA2_LENGTH, NULL, GCK_DERIVEKEY_DATA3_LENGTH, pcommand_response);        // Assigning the data parameters of the command (only CRC calculation is performed).
     
      // Assign response parameters of the command
      Assign_Response_Params(pcommand_response, GCK_DERIVEKEY_RESPONSE_LENGTH, SET_ATSHA_SLEEP);

      // Determine state transitions  
      Assign_PL1_States(PL2_BUSY_CYCLE, GENERATE_CHILD_KEY_1);          

      // Assign output flag.
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;   

    case (GENERATE_CHILD_KEY_1):       
      // Decrypt the parent key stored in flash
      Flash_Array_Decryption(&(PL1_data.parent_key[0]), encrypted_ParentKey1, 8);   // Read and decrypt the first eight bytes of parent key.
      Flash_Array_Decryption(&(PL1_data.parent_key[8]), encrypted_ParentKey2, 8);   // .... second ... .
      Flash_Array_Decryption(&(PL1_data.parent_key[16]), encrypted_ParentKey3, 8);  // Read and decrypt the third eight bytes of parent key.
      Flash_Array_Decryption(&(PL1_data.parent_key[24]), encrypted_ParentKey4, 8);  // .... fourth ... .
      
      // Determine state transitions  
      Assign_PL1_States(GENERATE_CHILD_KEY_12, GENERATE_CHILD_KEY_2);          
      
      // Assign output flag.
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;   

    case (GENERATE_CHILD_KEY_2):       
      // Create child key in host by invoking DeriveKey emulating software.
      sha204h_derive_key_in_out derive_key_params = {
        .random = GCK_DERIVEKEY_COMMAND,                   // Create and initialize the in/out structure of DeriveKey emulating software.
        .target_key_id = 0x0002,                           // The target key for the DeriveKey command.
        .parent_key = &(PL1_data.parent_key[0]),           // Assign parent key. 
        .target_key = &(PL1_data.childkey_bootsecret[0]),  // The array in which child key is kept is assigned.
        .temp_key = &TempKey,                              // Pointer to TempKey register is provided.
      };
      
      // Create a DeriveKey command output flag
      DeriveKeysoftware_output_flag output_flag;
      
      // Compute child key
      output_flag = sha204h_derive_key(&derive_key_params);           // Run the DeriveKey emulating software.
      
      // Determine state transitions        
      Assign_PL1_States(CREATE_ROPD_RCPD, CREATE_ROPD_RCPD_1);          

      // Assign output flag.
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;   

    case (CREATE_ROPD_RCPD):      
      // Create RCPD by invoking MAC emulating software.
      memcpy(&(TempKey.value[0]), &((*pcommand_response).response[RESPONSE_COUNT_OFFSET]), ATSHA_NONCE_LENGTH);                 // Copy the nonce generated by ATSHA to TempKey register.
      Assign_TempKey(0, TEMPKEY_RAND_SOURCE, TEMPKEY_GENDATA_IGNORE, TEMPKEY_CHECKFLAG_NOGENDIG, TEMPKEY_VALID, *pTempKey);     // Assign the registers of TempKey.

      // Create a MAC command structure.   
      sha204h_mac_in_out param{        
                .mode = 0x45,
		.key_id = 0x00,
		.key = &CPD_RCPD[0],
		.sn = &serial_number[0],
		.response = &CPD_RCPD[0],        // Response is also put into this vector.
		.temp_key = &TempKey,            // Note that TempKey.Value holds the nonce at this point.
		};
      
      // Create a MAC command output flag
      MACsoftware_output_flag    output_flag;
      
      // Compute MAC
      output_flag = sha204h_mac(&param);
      
      // Determine state transitions        
      if (output_flag == MAC_COMPUTATION_COMPLETE)        
        Assign_PL1_States(CREATE_ROPD_RCPD, CREATE_ROPD_RCPD_1);      // If MAC computation is complete, go to the next state.
      else
        Assign_PL1_States(CREATE_ROPD_RCPD_1, CREATE_ROPD_RCPD_2);    // Else repeat this state.
            
      // Assign output flag
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;   

    case (CREATE_ROPD_RCPD_1):       
      // Decrypt the OPD stored in flash
      Flash_Array_Decryption(&(PL1_data.OPD_ROPD[0]), encrypted_OPD1, 8);   // Read and decrypt the first eight bytes of OPD.
      Flash_Array_Decryption(&(PL1_data.OPD_ROPD[8]), encrypted_OPD2, 8);   // .... second ... .
      Flash_Array_Decryption(&(PL1_data.OPD_ROPD[16]), encrypted_OPD3, 8);  // Read and decrypt the third eight bytes of OPD.
      Flash_Array_Decryption(&(PL1_data.OPD_ROPD[24]), encrypted_OPD4, 8);  // .... fourth ... .
      
      // Determine state transitions  
      Assign_PL1_States(CREATE_ROPD_RCPD_2, COMPUTE_SIGNATURE);          
      
      // Assign output flag.
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;   

    case (CREATE_ROPD_RCPD_2):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   
      
    case (COMPUTE_SIGNATURE):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   
      
    case (COMPUTE_SIGNATURE_1):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   

    case (COMPUTE_SIGNATURE_2):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   

    case (AUTHENTICATION):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   
      
    case (AUTHENTICATION_1):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   

    case (AUTHENTICATION_2):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   

    case (CHECK_ACK_AUTHENTICITY):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   

    case (CHECK_ACK_AUTHENTICITY_1):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   

    case (CHECK_ACK_AUTHENTICITY_2):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   

    case (CHECK_ACK_AUTHENTICITY_3):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   

    case (CHECK_ACK_AUTHENTICITY_4):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   

    case (CHECK_ACK_AUTHENTICITY_5):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      PL1_output_flag =
      break;   
      
    case (PL2_BUSY_CYCLE):
      PL2_output_flag = ATSHA_PL2(pcommand_response, current_system_time);       // Send the desired command to level 2 and assess the status of this level. 
                                                                                 // Note: This function has been implemented here to render the second implementation approach possible (see the report). It could be deleted for method I.
      Change_PL1_State(PL2_output_flag);     // Assign the next state of PL1 based on the output flag of PL2. 
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;       
    
    default:  // Facing an unknown state, decide on the next state based on the output flags of level two. 
      if (PL2_output_flag == PL2_BUSY)  // If PL2 is still busy, jump to PL2 BUSY state, then go to the initial state of the protocol.
      {
        Assign_PL1_States(PL2_BUSY_CYCLE, PL1_INITIALIZATION);                                                              
      }
      else if (PL2_output_flag == PL2_FAILURE)  // Else a failure has occured
      {
        Assign_PL1_States(LEVEL_TWO_FAILURE,PL2_BUSY_CYCLE);     // Jump to the failure state.                                                                  
      }
      else if (PL2_output_flag == PL2_READY || PL2_output_flag == PL2_FINISHED)
      {
        Assign_PL1_States(PL1_INITIALIZATION,PL2_BUSY_CYCLE);     // For these cases we can restart the authentication algorithm.
      }
      else      // Else, restart the programming protocol.
      {
        Assign_PL1_States(PL2_BUSY_CYCLE,PL1_INITIALIZATION);            
      }          
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;
    
    case (LEVEL_TWO_FAILURE): 
      Assign_PL1_States(PL2_BUSY_CYCLE,PL1_data.next_PL1_state,PL1_BUSY,UPDATE_COMPLETE);      // First, return back to PL2_BUSY_CYCLE to try and retransmit the failed command. Then jump to the next state of ATSHA.                                                                             
      PL1_internal_flags.success_failure_flag = PL1_FAILURE;
      PL1_output_flag = PL1_BUSY;      // Return a busy flag.
      break;      

    case (AUTHENTICATION_FINALIZATION):
      PL1_output_flag =
      break;
      
  }
    
     //// Finalization
     return(PL1_output_flag);
}

void Assign_PL1_States(unsigned char current_state, unsigned char next_state)
{ 
  // Initialization
  
  
  // Main commands
  PL1_data.current_PL1_state = current_state;
  PL1_data.next_PL1_state = next_state;

  
  // Finalization

}

void Change_PL1_State(PL2_flags PL2_output_flag)
{
  // Initialization
  
  
  // Main commands
  if (PL2_output_flag == PL2_BUSY)    // If PL2 is still busy with this state.
  {
    PL1_data.current_PL1_state = PL1_data.current_PL1_state;    // Continue with this state!
  }
  else if (PL2_output_flag == PL2_FINISHED || PL2_output_flag == PL2_READY)   // Else PL2 has finihsed this state or is ready to begin a new state.
  {
    PL1_data.current_PL1_state = PL1_data.next_PL1_state;        // Go to the next state!
  }
  else if (PL2_output_flag == PL2_FAILURE)  // Else a failure has been returned.
  {
    PL1_data.current_PL1_state = LEVEL_TWO_FAILURE;     // Progamming has failed.
  }
  else
  {
    PL1_data.current_PL1_state = PL2_BUSY_CYCLE;    // Continue with PL2 BUSY CYCLE if the output flag of ATSHA is meaningless!    
  }
  
   
  // Finalization
}

void Flash_Array_Decryption(unsigned char *pvec1, unsigned char __flash *pvec2, unsigned char length)
{
  // Initialization

  
  // Main commands
  while (length--)
  {
      *pvec1 = *pvec2++;                                               // Swap each element of the vectors.
      *pvec1 = ((*pvec1 & 0x0F) << 4) + ((*pvec1 & 0xF0) >> 4);        // Swaping four LSB and MSB bits.
      *pvec1 = ((~*pvec1)^XOR_BYTE);                                   // Negating the results and XORing.
       pvec1++;                                                        // Increment pointer to vector one.
  }
  
  
  // Finalization
  
}
