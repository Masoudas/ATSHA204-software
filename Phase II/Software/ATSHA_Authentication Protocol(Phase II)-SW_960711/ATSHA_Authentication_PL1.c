/*******************************************************************************
********************************************************************************
*@ File:	ATSHA_Authentication_PL1.c
****************************************
*@ Company:	Sadr Electronic Dena Co.

*@ Version:	1.0
*@ Update:	Last:96/07/11	Previous:96/07/11	Created:96/07/11
*@ Author:	M. Aghamohamadian.

*@ Brief:	This header contains the main authentication protocol with ATSHA.

*@ Note:        See the report for definition of implementation levels of programmer
                (and authentication) protocols of ATSHA.
********************************************************************************
*******************************************************************************/
#include "ATSHA_Authentication_PL1.h"
#include "ATSHA_PL2.h"
#include "ATSHA_Commands_Module.h"
#include <stdio.h>

PL1_data_struct                  PL1_data = {??};
PL1_internal_flags_struct        PL1_internal_flags = {???};
sha204h_temp_key                 TempKey;


PL1_flags ATSHA_Authentication_PL1(command_response_struct *pcommand_response, unsigned int current_system_time)
{
  //// Initialization
  PL2_flags                        PL2_output_flag;                   // Output flag of level two.
  
  
  //// Main Commands
  switch (PL1_data.current_PL1_state)    
  {
    case (PL1_INITIALIZATION):       
      Assign_PL1_States(GENERATE_NONCE_1,GENERATE_NONCE_2);          
      return(PL1_BUSY);      // Return a busy flag.
      break;   

    case (GENERATE_NONCE):       
      Generate_Nonce(command_response_struct *pcommand_response, unsigned int current_system_time);     // Generate a nonce in host.
      Assign_PL1_States(GENERATE_NONCE_1, PL2_BUSY_CYCLE);          // The next state assigned here is unneccessary.
      return(PL1_BUSY);
      break;   

    case (GENERATE_NONCE_1):     
      // Assigning the command buffer (Note: Parameters should always be assigned first!).
      Assign_CommandParams(GN1_NONCE_COMMAND, COMMAND_WORD_ADDRESS, GN1_NONCE_COUNT, GN1_NONCE_OPCODE, GN1_NONCE_PARAM1, GN1_NONCE_PARAM20, GN1_NONCE_PARAM21, pcommand_response);       // Assigning the parameters of a command.
      Assign_CommandData(&(PL_data.Nonce[0]), GN1_NONCE_DATA1_LENGTH, NULL, GN1_NONCE_DATA2_LENGTH, NULL, GN1_NONCE_DATA3_LENGTH, pcommand_response);        // Assigning the data parameters of the command (only 20 bytes of nonce are used).
     
      // Assign response parameters of the command
      Assign_Response_Params(pcommand_response, GN1_NONCE_RESPONSE_LENGTH, SET_ATSHA_IDLE);

      // Determine state transitions  
      Assign_PL1_States(PL2_BUSY_CYCLE, READ_DZ_207);          

      // Assign output flag.
      return(PL1_BUSY);      
      break;   
      
    case (GENERATE_NONCE_2):           
      // Copy the nonce generated by ATSHA to registers.
      memcpy(&(TempKey.value[0]), &((*pcommand_response).response[RESPONSE_COUNT_OFFSET]), ATSHA_NONCE_LENGTH);  // Copy the nonce generated by ATSHA to TempKey register.
      memcpy(&(PL1_data.nonce[0]), &(TempKey.value[0]), TEMPKEY_VALUE_LENGTH);          // Copy the nonce in TempKey.value to nonce[] for future uses.
      Assign_TempKey(0, TEMPKEY_RAND_SOURCE, TEMPKEY_GENDATA_IGNORE, TEMPKEY_CHECKFLAG_NOGENDIG, TEMPKEY_VALID, *pTempKey);     // Assign the registers of TempKey.
      
      // Determine state transitions  
      Assign_PL1_States(GENERATE_CHILD_KEY, PL2_BUSY_CYCLE);          

      // Assign output flag.
      return(PL1_BUSY);           
      break;

    case (GENERATE_CHILD_KEY):             
      // Assigning the command buffer
      Assign_CommandParams(GCK_DERIVEKEY_COMMAND, COMMAND_WORD_ADDRESS, GCK_DERIVEKEY_COUNT, GCK_DERIVEKEY_OPCODE, GCK_DERIVEKEY_PARAM1, GCK_DERIVEKEY_PARAM20, GCK_DERIVEKEY_PARAM21, pcommand_response);       // Assigning the parameters of a command.
      Assign_CommandData(NULL, GCK_DERIVEKEY_DATA1_LENGTH, NULL, GCK_DERIVEKEY_DATA2_LENGTH, NULL, GCK_DERIVEKEY_DATA3_LENGTH, pcommand_response);        // Assigning the data parameters of the command (only CRC calculation is performed).
     
      // Assign response parameters of the command
      Assign_Response_Params(pcommand_response, GCK_DERIVEKEY_RESPONSE_LENGTH, SET_ATSHA_SLEEP);

      // Determine state transitions  
      Assign_PL1_States(PL2_BUSY_CYCLE, GENERATE_CHILD_KEY_1);          

      // Assign output flag.
      return(PL1_BUSY);      
      break;   

    case (GENERATE_CHILD_KEY_11):       
      // Decrypt the parent key stored in flash
      Flash_Array_Decryption(&(PL1_data.parent_key[0]), encrypted_ParentKey1, 8);   // Read and decrypt the first eight bytes of parent key.
      Flash_Array_Decryption(&(PL1_data.parent_key[8]), encrypted_ParentKey2, 8);   // .... second ... .
      
      // Determine state transitions  
      Assign_PL1_States(GENERATE_CHILD_KEY_12, GENERATE_CHILD_KEY_2);          
      
      // Assign output flag.
      return(PL1_BUSY);      
      break;   

    case (GENERATE_CHILD_KEY_12):       
      // Decrypt the parent key stored in flash
      Flash_Array_Decryption(&(PL1_data.parent_key[16]), encrypted_ParentKey3, 8);  // Read and decrypt the third eight bytes of parent key.
      Flash_Array_Decryption(&(PL1_data.parent_key[24]), encrypted_ParentKey4, 8);  // .... fourth ... .
      
      // Determine state transitions        
      Assign_PL1_States(GENERATE_CHILD_KEY_2, CREATE_ROPD_RCPD);          

      // Assign output flag.
      return(PL1_BUSY);      
      break;   

    case (GENERATE_CHILD_KEY_2):       
      // Create child key in host by invoking DeriveKey emulating software.
      sha204h_derive_key_in_out derive_key_params = {.random = GCK_DERIVEKEY_COMMAND,                   // Create and initialize the in/out structure of DeriveKey emulating software.
                                        	     .target_key_id = 0x0002,                           // The target key for the DeriveKey command.
                                                     .parent_key = &(PL1_data.parent_key[0]),           // Assign parent key. 
                                                     .target_key = &(PL1_data.childkey_bootsecret[0]),  // The array in which child key is kept is assigned.
	                                             .temp_key = &TempKey,                              // Pointer to TempKey register is provided.
                                                    };
      sha204h_derive_key(&derive_key_params);           // Run the DeriveKey emulating software.
      
      // Determine state transitions        
      Assign_PL1_States(CREATE_ROPD_RCPD, CREATE_ROPD_RCPD_1);          

      // Assign output flag.
      return(PL1_BUSY);      
      break;   

    case (CREATE_ROPD_RCPD):       ???????????????????????????????????????????????????????????????????????????
      // Definition of the required local variables.
      unsigned char     temp[64] = {0};                     // A temp array which contains the input message to SHA256 that forms RCPD.
      struct            sha204h_calculate_sha256_in_out calculate_sha256_param;          // Structure for calculation of SHA256.
      SHA256_output_flag
      
      // Copying the required data to the temp vector.
      memcpy(temp, &CPD_RCPD[0], 32);                   // Copy the content of CPD first.
      memcpy(temp + 32, &nonce[0], 32);                 // Attach the nonce to this vector.

      // Assign SHA command parameters.
      calculate_sha256_param.length  = RCPD_ROPD_GENERATION_MESSAGE_SIZE;
      calculate_sha256_param.message = &temp[0];                 
      calculate_sha256_param.digest  = &CPD_RCPD[0];         
      
      // Calculate SHA.
      SHA256_output_flag = sha204h_calculate_sha256(&calculate_sha256_param);

      if (SHA256_output_flag == SHA256_COMPLETED)
        Assign_PL1_States(CREATE_ROPD_RCPD, CREATE_ROPD_RCPD_1);    // If the SHA calculation is not finished, repeat this process.
      else
        Assign_PL1_States(CREATE_ROPD_RCPD_1, CREATE_ROPD_RCPD_2);    // If the SHA calculation is not finished, repeat this process.
            
      // Assign output flag.
      return(PL1_BUSY);  
      break;   

    case (CREATE_ROPD_RCPD_11):       
      // Decrypt the OPD stored in flash
      Flash_Array_Decryption(&(PL1_data.ROPD[0]), encrypted_OPD1, 8);   // Read and decrypt the first eight bytes of OPD.
      Flash_Array_Decryption(&(PL1_data.ROPD[8]), encrypted_OPD2, 8);   // .... second ... .
      
      // Determine state transitions  
      Assign_PL1_States(CREATE_ROPD_RCPD_12, CREATE_ROPD_RCPD_2);          
      
      // Assign output flag.
      return(PL1_BUSY);      
      break;   

    case (CREATE_ROPD_RCPD_12):       
      // Decrypt the OPD stored in flash
      Flash_Array_Decryption(&(PL1_data.ROPD[16]), encrypted_OPD3, 8);  // Read and decrypt the third eight bytes of OPD.
      Flash_Array_Decryption(&(PL1_data.ROPD[24]), encrypted_OPD4, 8);  // .... fourth ... .
      
      // Determine state transitions        
      Assign_PL1_States(CREATE_ROPD_RCPD_2, COMPUTE_SIGNATURE);          

      // Assign output flag.
      return(PL1_BUSY);   
      break;   

    case (CREATE_ROPD_RCPD_2):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   
      
    case (COMPUTE_SIGNATURE):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   
      
    case (COMPUTE_SIGNATURE_1):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   

    case (COMPUTE_SIGNATURE_2):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   

    case (AUTHENTICATION):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   
      
    case (AUTHENTICATION_1):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   

    case (AUTHENTICATION_2):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   

    case (CHECK_ACK_AUTHENTICITY):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   

    case (CHECK_ACK_AUTHENTICITY_1):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   

    case (CHECK_ACK_AUTHENTICITY_2):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   

    case (CHECK_ACK_AUTHENTICITY_3):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   

    case (CHECK_ACK_AUTHENTICITY_4):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   

    case (CHECK_ACK_AUTHENTICITY_5):       
      Assign_CommandData();
      Assign_CommandParams();

      Assign_Response_Params(pcommand_response,RCZ007_RESPONSE_LENGTH,SET_ATSHA_SLEEP);
      Assign_PL1_States(PL2_BUSY_CYCLE,READ_DZ_207);          
      return();
      break;   
      
    case (PL2_BUSY_CYCLE):
      PL2_output_flag = ATSHA_PL2(pcommand_response, current_system_time);       // Send the desired command to level 2 and assess the status of this level. 
                                                                                 // Note: This function has been implemented here to render the second implementation approach possible (see the report). It could be deleted for method I.
      Change_PL1_State(PL2_output_flag);     // Assign the next state of PL1 based on the output flag of PL2. 
      return(PL1_BUSY);      // Return a busy flag.
      break;       
    
    default:  // Facing an unknown state, decide on the next state based on the output flags of level two. 
      if (PL2_output_flag == PL2_BUSY)  // If PL2 is still busy, jump to PL2 BUSY state, then go to the initial state of the protocol.
      {
        Assign_PL1_States(PL2_BUSY_CYCLE, AUTHENTICATION_INITIATION);                                                              
      }
      else if (PL2_output_flag == PL2_FAILURE)  // Else a failure has occured
      {
        Assign_PL1_States(LEVEL_TWO_FAILURE,PL2_BUSY_CYCLE);     // Jump to the failure state.                                                                  
      }
      else if (PL2_output_flag == PL2_READY || PL2_output_flag == PL2_FINISHED)
      {
        Assign_PL1_States(AUTHENTICATION_INITIATION,PL2_BUSY_CYCLE);     // For these cases we can restart the authentication algorithm.
      }
      else      // Else, restart the programming protocol.
      {
        Assign_PL1_States(PL2_BUSY_CYCLE,AUTHENTICATION_INITIATION);            
      }          
      return(PL1_BUSY);      // Return a busy flag.
      break;
    
    case (LEVEL_TWO_FAILURE): 
      Assign_PL1_States(PL2_BUSY_CYCLE,PL1_data.next_PL1_state,PL1_BUSY,UPDATE_COMPLETE);      // First, return back to PL2_BUSY_CYCLE to try and retransmit the failed command. Then jump to the next state of ATSHA.                                                                             
      PL1_internal_flags.success_failure_flag = PL1_FAILURE;
      return(PL1_BUSY);      
      break;      

    case (AUTHENTICATION_FINALIZATION):
      
      break;
      
  }
    
     //// Finalization

}

void Assign_PL1_States(unsigned char current_state, unsigned char next_state)
{ 
  // Initialization
  
  
  // Main commands
  PL1_data.current_PL1_state = current_state;
  PL1_data.next_PL1_state = next_state;

  
  // Finalization

}

void Change_PL1_State(PL2_flags PL2_output_flag)
{
  // Initialization
  
  
  // Main commands
  if (PL2_output_flag == PL2_BUSY)    // If PL2 is still busy with this state.
  {
    PL1_data.current_PL1_state = PL1_data.current_PL1_state;    // Continue with this state!
  }
  else if (PL2_output_flag == PL2_FINISHED || PL2_output_flag == PL2_READY)   // Else PL2 has finihsed this state or is ready to begin a new state.
  {
    PL1_data.current_PL1_state = PL1_data.next_PL1_state;        // Go to the next state!
  }
  else if (PL2_output_flag == PL2_FAILURE)  // Else a failure has been returned.
  {
    PL1_data.current_PL1_state = LEVEL_TWO_FAILURE;     // Progamming has failed.
  }
  else
  {
    PL1_data.current_PL1_state = PL2_BUSY_CYCLE;    // Continue with PL2 BUSY CYCLE if the output flag of ATSHA is meaningless!    
  }
  
   
  // Finalization
}

void Flash_Array_Decryption(unsigned char *pvec1, unsigned char __flash *pvec2, unsigned char length)
{
  // Initialization

  
  // Main commands
  while (length--)
  {
      *pvec1 = *pvec2++;                                               // Swap each element of the vectors.
      *pvec1 = ((*pvec1 & 0x0F) << 4) + ((*pvec1 & 0xF0) >> 4);        // Swaping four LSB and MSB bits.
      *pvec1 = ((~*pvec1)^XOR_BYTE);                                   // Negating the results and XORing.
       pvec1++;                                                        // Increment pointer to vector one.
  }
  
  
  // Finalization
  
}
